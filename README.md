# Python gRPC Service with Bazel: Project Guide

## Overview
This project is a minimal, production-grade Python gRPC service built and managed with Bazel. It demonstrates best practices for Bazel Python projects, including:
- Modern dependency management with bzlmod (`MODULE.bazel`)
- gRPC service definition and code generation
- Clean Bazel package structure
- Robust handling of Python imports and generated code

---

## Quickstart Commands

### Build the server
```sh
bazel build //khushal_hello_grpc/src/server:hello_server
```

### Run the server
```sh
bazel run //khushal_hello_grpc/src/server:hello_server
```

### Run tests
```sh
bazel test //khushal_hello_grpc/tests:test_server
```

### Update Python dependencies
```sh
python3 -m piptools compile requirements.in --output-file=requirements_lock.txt --allow-unsafe
```
> **Note:** We use `requirements_lock.txt` (not the default `requirements.txt`) to ensure fully reproducible builds for Bazel. The `--output-file` flag is required because piptools by default writes to `requirements.txt`, but Bazel bzlmod expects a lock file with a custom name. The `--allow-unsafe` flag is necessary for Bazel because some dependencies (like grpcio-tools) require "unsafe" packages (such as setuptools) to be present in the lock file.

---

## Project Structure
```
hello_grpc/
├── khushal_hello_grpc/
│   ├── src/
│   │   ├── server/
│   │   │   ├── server.py
│   │   │   └── impl/
│   │   │       └── service_impl.py
│   │   └── generated/
│   │       └── (generated .py)
│   └── tests/
│       ├── test_server.py
│       └── BUILD.bazel
├── protos/
│   ├── BUILD.bazel
│   └── hello.proto
├── MODULE.bazel
├── requirements.in
├── requirements_lock.txt
```

---

## What are MODULE.bazel and MODULE.bazel.lock?
- **MODULE.bazel**: This file is the root configuration for Bazel's new dependency management system, called bzlmod. It declares your project's external dependencies (like `rules_python`), configures toolchains, and sets up extensions (such as pip integration for Python). Think of it as the Bazel equivalent of a `pyproject.toml` or `package.json` for your build and dependency setup.
- **MODULE.bazel.lock**: This file is automatically generated by Bazel when you run builds. It locks the exact versions and resolved dependency graph for all modules and extensions declared in `MODULE.bazel`. You should add this file to your `.gitignore` because it is machine-generated and will be recreated as needed.

---

## Why Bazel? Why BUILD.bazel Files?
- **Bazel** provides reproducible, hermetic builds and enforces clear package boundaries.
- Each directory with a `BUILD.bazel` is a Bazel package. This ensures:
  - Code in one package can only depend on other packages via Bazel targets (not direct file paths).
  - Dependencies are explicit and controlled.
- `BUILD.bazel` files define how code is built, what dependencies it has, and what is visible to other packages.

---

## Why `__init__.py` Files?
- Every Python package directory (e.g., `server/`, `server/impl/`, `generated/`) must have an `__init__.py` file.
- This makes the directory a Python package, enabling absolute imports and correct module resolution.
- Without `__init__.py`, Python and Bazel may not recognize the directory as a package, leading to import errors.

---

## Proto Generation and the `genrule`
### What We Tried First
- We tried using Bazel's `proto_library` and `py_proto_library` rules, but these do not support gRPC Python code generation out-of-the-box.
- We also tried generating protos directly into the `generated/` directory, but ran into import issues due to how the generated code references each other.

### Why We Use a `genrule`
- The `genrule` in `generated/BUILD.bazel` runs `grpc_tools.protoc` to generate both `hello_pb2.py` and `hello_pb2_grpc.py`.
- We patch the generated `hello_pb2_grpc.py` to use a relative import (`from . import hello_pb2 as hello__pb2`) so it works as a package import under Bazel.
- This ensures all generated code can be imported as `from generated import hello_pb2, hello_pb2_grpc` in your code, and avoids import errors.

#### Example `genrule`:
```python
genrule(
    name = "generate_hello_grpc",
    srcs = ["//protos:hello.proto"],
    outs = [
        "hello_pb2.py",
        "hello_pb2_grpc.py",
        "__init__.py",
    ],
    cmd = "touch $(@D)/__init__.py && cp $(location //protos:hello.proto) $(@D)/hello.proto && cd $(@D) && python3 -m grpc_tools.protoc -I. --python_out=. --grpc_python_out=. hello.proto && sed -i '' 's/import hello_pb2 as hello__pb2/from . import hello_pb2 as hello__pb2/' hello_pb2_grpc.py",
    tools = [requirement("grpcio-tools")],
)
```

---

## Python Imports: Best Practices
- Always use **absolute imports** in your code, e.g.:
  ```python
  from generated import hello_pb2, hello_pb2_grpc
  from server.impl.service_impl import HelloService
  ```
- Never import generated files as top-level modules (e.g., `import hello_pb2`) unless you explicitly add the directory to `PYTHONPATH` (not recommended with Bazel).
- The patched `genrule` ensures the generated files use relative imports internally, so everything works as a package.

---

## Troubleshooting & Lessons Learned
- **Import errors** (e.g., `ModuleNotFoundError: No module named 'hello_pb2'`) are almost always due to:
  - Incorrect import style (top-level vs. package import)
  - Missing `__init__.py` files
  - Not patching the generated code to use relative imports
- **Bazel package boundaries**: Never reference files in subpackages directly; always depend on Bazel targets.
- **Proto package**: If you use a `package` statement in your proto, it affects the output directory structure and imports. For simplicity, omit it unless you want nested packages.
- **Regeneration**: Bazel will automatically regenerate protos when the `.proto` file or `genrule` changes. No manual steps needed.

---

## Usage

### What is a Bazel `genrule`?
A `genrule` is a flexible Bazel build rule that allows you to run arbitrary shell commands as part of your build process. In this project, we use a `genrule` to invoke the gRPC Python code generator (`grpc_tools.protoc`) and patch the generated files for correct imports. This approach is necessary because Bazel does not provide a built-in rule for Python gRPC code generation.

### Build the server:
```sh
bazel build //server:hello_server
```

### Run the server:
```sh
bazel run //server:hello_server
```

> **Note:** Every time you build or run the server, Bazel automatically regenerates the proto files. This is enabled by the custom `genrule` in `generated/BUILD.bazel`, which runs the gRPC Python code generator and patches imports as needed. Using a `genrule` for Python gRPC proto generation is the standard and recommended practice with Bazel, since there is no built-in Bazel rule for Python gRPC codegen. This ensures that the latest proto definitions are always used at runtime, and you never need to check in or manually update generated code.

### Add dependencies:
- Edit `requirements.in`, then run `python3 -m piptools compile requirements.in --output-file=requirements_lock.txt --allow-unsafe` to update `requirements_lock.txt`.
- Bazel will pick up changes automatically via bzlmod and `pip_parse`.

---

## Summary
This project demonstrates a robust, idiomatic Bazel Python gRPC setup:
- All proto code is generated at build time
- Imports are always correct and robust
- Bazel package boundaries are respected
- The build is reproducible and easy to extend

If you add more protos or services, just follow the same pattern!

> **Note:** Bazel can run pytest-style tests out of the box. You do **not** need to add `requirement("pytest")` to your `py_test` deps—just write your tests using pytest conventions and Bazel's test runner will handle them. If you add `requirement("pytest")` to `deps`, Bazel will try to resolve it as a target, which may fail depending on your pip integration.

## Important Versions Used

- **rules_python:** 0.40.0
- **Python:** 3.11
- **grpcio:** 1.71.0
- **grpcio-tools:** 1.71.0
- **protobuf:** 5.29.4
- **requests:** 2.32.3
- **pytest:** 8.3.5

See `requirements_lock.txt` for the full list of pinned Python dependencies. 